#pragma once

#include <iostream>
#include <utility>

// A class has several special members that can be implemented, by default, by the
// compiler. These are the default constructor, copy constructor, move constructor, copy
// assignment, move assignment, and destructor.

// If you explicitly provide one or more of these special methods, then the compiler will
// not generate the others according to the following rules:

// 1. If a user-defined constructor exists, the default constructor is not generated by
// default.

// 2. If a user-defined virtual destructor exists, the default constructor is not
// generated by default.

// 3. If a user-defined move constructor or move assignment operator exists, then the copy
// constructor and copy assignment operator are not generated by default.

// 4. If a user-defined copy constructor, move constructor, copy assignment operator, move
// assignment operator, or destructor exists, then the move constructor and move
// assignment operator are not generated by default.

// The RULE OF THUMB (also known as THE RULE OF FIVE) for class special member functions
// is that, if you explicitly define any copy constructor, move constructor, copy
// assignment operator, move assignment operator, or destructor, then you must either
// explicitly define or default all of them.

namespace recipe_3_01 {
  // 1.
  // ------------------------------------------------------------------------------------------------
  // obsolete style to prevent copying of objects
  class foo_not_copyable {
    // OBSOLETE style: public constructor and private copy and assigment constructors.
    // Problem: explicitly the defined default constructor ensures the class is no longer
    // considered trivial and, therefore, a POD type (that can be constructed with
    // reinterpret_cast).
  public:
    foo_not_copyable(){};

  private:
    foo_not_copyable(foo_not_copyable const&);
    foo_not_copyable& operator=(foo_not_copyable const&);
  };

  // 2.
  // ------------------------------------------------------------------------------------------------
  // new style to prevent copying of objects

  // To implement a class that is not copyable, and implicitly not movable, declare the
  // copy operations as deleted.
  class bar_not_copyable {
  public:
    // To default a function, use =default instead of the function body. Only special
    // class member functions that have defaults can be defaulted.
    bar_not_copyable() = default;

    // To delete a function, use =delete instead of the function body. Any function,
    // including non-member functions, can be deleted. Note: still in public.
    bar_not_copyable(bar_not_copyable const&) = delete;
    bar_not_copyable& operator=(bar_not_copyable const&) = delete;
  };

  struct Data {
  };

  // 3.
  // ------------------------------------------------------------------------------------------------
  // not copyable, but movable

  // To implement a class that is not copyable, but is movable, declare the copy
  // operations as deleted and explicitly implement the move operations (and provide any
  // additional constructors that are needed).
  class data_wrapper {
    Data* data;

  public:
    data_wrapper(Data* d = nullptr)
      : data(d)
    {
    }
    ~data_wrapper()
    {
      delete data;
    }

    data_wrapper(data_wrapper const&) = delete;
    data_wrapper& operator=(data_wrapper const&) = delete;

    // implement move constructor
    data_wrapper(data_wrapper&& o)
      : data(std::move(o.data))
    {
      o.data = nullptr;
    }

    // implement move assignment
    data_wrapper& operator=(data_wrapper&& o)
    {
      if (this != &o) {
        delete data;
        data = std::move(o.data);
        o.data = nullptr;
      }

      return *this;
    }
  };

  // 4.
  // ------------------------------------------------------------------------------------------------
  // inline functions

  class foo {
  public:
    foo() = default;

    inline foo& operator=(foo const&);
  };

  // inline functions can be declared '= default' outside the class body.
  inline foo& foo::operator=(foo const&) = default;

  // 5.
  // ------------------------------------------------------------------------------------------------
  // forward declarations

  // void forward_declared_function();

  // Note that previously declared functions cannot be deleted, as the =delete definition
  // must be the first declaration in a translation unit:

  // ...

  // void forward_declared_function() = delete; // Error!

  // 6.
  // ------------------------------------------------------------------------------------------------
  // free functions

  // To ensure a function is called only with objects of a specific type, and perhaps
  // prevent type promotion, provide deleted overloads for the function (the following
  // example with free functions can also be applied to any class member functions).
  template <typename T>
  void run(T) = delete;
  void run(long) {} // // can only be called with long integers

  //------------------------------------------------------------------------------------------------

  void execute()
  {
    std::cout << "Recipe 3.01: Defaulted and deleted functions.\n"
              << "---------------------------------------------\n"
              << "Please check source code!\n\n";

    {
      // foo_not_copyable f1, f2;
      // foo_not_copyable f3 = f1; // Error: private constructor
      // f1 = f2; // error
    }

    {
      // bar_not_copyable f1, f2;
      // bar_not_copyable f3 = f1; // Error: deleted constructor
      // f1 = f2; // error
    }

    {
      // run(42); // Error: matches a deleted overload.
      run(42L); // OK
    }
  }
}
